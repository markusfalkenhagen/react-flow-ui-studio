# Verhaltenskodex

Wir verpflichten uns, eine freundliche und einladende Umgebung für alle zu schaffen, unabhängig von Alter, Körpergröße, sichtbarer oder unsichtbarer Behinderung, ethnischer Zugehörigkeit, Geschlechtsmerkmalen, Geschlechtsidentität und -ausdruck, Erfahrungsniveau, Bildung, sozioökonomischem Status, Nationalität, persönlichem Erscheinungsbild, Rasse, Religion oder sexueller Identität und Orientierung.

Wir, als Mitwirkende und Verwalter dieses Projekts, versprechen, die Teilnahme an unserer Gemeinschaft zu einer belästigungsfreien Erfahrung für alle zu machen, unabhängig von Alter, Körpergröße, sichtbarer oder unsichtbarer Behinderung, ethnischer Zugehörigkeit, Geschlechtsmerkmalen, Geschlechtsidentität und -ausdruck, Erfahrungsniveau, Bildung, sozioökonomischem Status, Nationalität, persönlichem Erscheinungsbild, Rasse, Religion oder sexueller Identität und Orientierung.

## Unsere Standards

Beispiele für Verhaltensweisen, die zu einer positiven Umgebung für unsere Gemeinschaft beitragen:

*   Demonstration von Empathie und Freundlichkeit gegenüber anderen Menschen
*   Respektvolles Verhalten gegenüber unterschiedlichen Meinungen, Standpunkten und Erfahrungen
*   Annahme von konstruktiver Kritik und Anmut
*   Konzentration auf das, was für die Gemeinschaft am besten ist
*   Zeigen von Empathie gegenüber anderen Community-Mitgliedern

Beispiele für inakzeptables Verhalten:

*   Die Verwendung sexualisierter Sprache oder Bilder sowie unerwünschte sexuelle Aufmerksamkeit oder Annäherungsversuche
*   Trolling, beleidigende/abfällige Kommentare und persönliche oder politische Angriffe
*   Öffentliche oder private Belästigung
*   Veröffentlichung privater Informationen anderer, wie z.B. einer physischen oder elektronischen Adresse, ohne deren ausdrückliche Genehmigung
*   Anderes Verhalten, das in einem professionellen Umfeld vernünftigerweise als unangemessen angesehen werden könnte

## Durchsetzungspflichten

Die Projektverwalter sind für die Klärung und Durchsetzung unserer Standards für akzeptables Verhalten verantwortlich und werden bei jedem Verhalten, das sie als unangemessen, bedrohlich, beleidigend oder schädlich erachten, angemessene und faire Korrekturmaßnahmen ergreifen.

Die Projektverwalter haben das Recht und die Verantwortung, Kommentare, Commits, Code, Wiki-Bearbeitungen, Issues und andere Beiträge zu entfernen, zu bearbeiten oder abzulehnen, die nicht mit diesem Verhaltenskodex übereinstimmen, und vorübergehend oder dauerhaft jeden Mitwirkenden für Verhaltensweisen zu sperren, die sie als unangemessen, bedrohlich, beleidigend oder schädlich erachten.

## Geltungsbereich

Dieser Verhaltenskodex gilt innerhalb aller Projektbereiche und gilt auch, wenn eine Person das Projekt oder seine Gemeinschaft in öffentlichen Räumen vertritt. Beispiele für die Vertretung unseres Projekts oder unserer Gemeinschaft sind die Verwendung einer offiziellen Projekt-E-Mail-Adresse, das Posten über einen offiziellen Social-Media-Account oder das Handeln als ernannter Vertreter bei einer Online- oder Offline-Veranstaltung.

## Durchsetzung

Fälle von beleidigendem, belästigendem oder anderweitig inakzeptablem Verhalten können den Projektverwaltern gemeldet werden, indem Sie [Ihre E-Mail-Adresse oder einen anderen Kontaktweg hier einfügen]. Alle Beschwerden werden umgehend und fair geprüft.

Alle Projektverwalter sind verpflichtet, die Vertraulichkeit des Meldenden in Bezug auf den Vorfall zu wahren.

## Attributierung

Dieser Verhaltenskodex ist an den [Contributor Covenant](https://www.contributor-covenant.org) Version 2.0 angepasst, verfügbar unter [https://www.contributor-covenant.org/version/2/0/code_of_conduct.html](https://www.contributor-covenant.org/version/2/0/code_of_conduct.html).# Beitragen zu ReplicateAI

Wir freuen uns über Ihre Beiträge zu ReplicateAI! Bevor Sie beginnen, lesen Sie bitte diesen Leitfaden, um den Beitragsprozess zu verstehen und sicherzustellen, dass Ihre Beiträge reibungslos integriert werden können.

## Verhaltenskodex

Bitte beachten Sie unseren [Verhaltenskodex](CODE_OF_CONDUCT.md). Wir erwarten von allen Mitwirkenden, dass sie sich an diesen Kodex halten, um eine offene und einladende Umgebung zu gewährleisten.

## Wie man beiträgt

Es gibt viele Möglichkeiten, zu ReplicateAI beizutragen:

*   **Fehlerberichte**: Melden Sie Fehler, die Sie finden, indem Sie ein Issue öffnen.
*   **Feature-Vorschläge**: Schlagen Sie neue Features oder Verbesserungen vor.
*   **Code-Beiträge**: Schreiben Sie Code, um Fehler zu beheben oder neue Features zu implementieren.
*   **Dokumentations-Beiträge**: Verbessern Sie die bestehende Dokumentation oder fügen Sie neue hinzu.

### Fehlerberichte

Wenn Sie einen Fehler finden, öffnen Sie bitte ein neues Issue in unserem [GitHub-Repository](https://github.com/your-repo/replicateai/issues). Bitte fügen Sie so viele Details wie möglich hinzu:

*   Eine klare und prägnante Beschreibung des Fehlers.
*   Schritte zur Reproduktion des Fehlers.
*   Erwartetes Verhalten.
*   Tatsächliches Verhalten.
*   Ihre Umgebung (Betriebssystem, Node.js-Version, Browser usw.).
*   Screenshots oder Videos (falls zutreffend).

### Feature-Vorschläge

Wir freuen uns über Feature-Vorschläge! Öffnen Sie ein neues Issue und beschreiben Sie Ihr Feature so detailliert wie möglich. Erklären Sie, warum das Feature nützlich wäre und wie es funktionieren könnte.

### Code-Beiträge

1.  **Forken Sie das Repository**: Beginnen Sie damit, das ReplicateAI-Repository auf Ihr GitHub-Konto zu forken.
2.  **Klonen Sie Ihr Fork**: Klonen Sie Ihr geforktes Repository auf Ihren lokalen Computer:
    ```bash
    git clone https://github.com/your-username/replicateai.git
    cd replicateai
    ```
3.  **Abhängigkeiten installieren**: Installieren Sie alle erforderlichen Abhängigkeiten:
    ```bash
    npm install
    ```
4.  **Entwicklungs-Server starten**: Starten Sie die Anwendung im Entwicklungsmodus:
    ```bash
    npm run dev
    ```
5.  **Branch erstellen**: Erstellen Sie einen neuen Branch für Ihre Änderungen. Verwenden Sie einen beschreibenden Namen (z.B. `feature/add-dark-mode` oder `fix/login-bug`).
    ```bash
    git checkout -b feature/your-feature-name
    ```
6.  **Änderungen vornehmen**: Nehmen Sie Ihre Änderungen am Code vor. Stellen Sie sicher, dass Sie die [Style Guidelines](STYLE_GUIDE.md) befolgen.
7.  **Tests schreiben (falls zutreffend)**: Wenn Sie neue Features hinzufügen oder Fehler beheben, schreiben Sie bitte entsprechende Tests.
8.  **Änderungen committen**: Committen Sie Ihre Änderungen mit einer klaren und prägnanten Commit-Nachricht.
    ```bash
    git commit -m "feat: Add new feature"
    ```
9.  **Änderungen pushen**: Pushen Sie Ihren Branch zu Ihrem geforkten Repository:
    ```bash
    git push origin feature/your-feature-name
    ```
10. **Pull Request öffnen**: Öffnen Sie einen Pull Request (PR) von Ihrem geforkten Repository zum `main`-Branch des ursprünglichen ReplicateAI-Repositorys. Beschreiben Sie Ihre Änderungen detailliert und verweisen Sie auf alle relevanten Issues.

### Dokumentations-Beiträge

Verbesserungen an der Dokumentation sind immer willkommen! Wenn Sie Tippfehler finden, Erklärungen verbessern oder neue Abschnitte hinzufügen möchten, folgen Sie dem gleichen Prozess wie bei Code-Beiträgen (Forken, Branch erstellen, Änderungen vornehmen, PR öffnen).

## Style Guidelines

Bitte lesen Sie unsere [Style Guidelines](STYLE_GUIDE.md), um sicherzustellen, dass Ihr Code und Ihre Dokumentation konsistent mit dem Projektstil sind.

Vielen Dank für Ihre Beiträge!# Style Guide für ReplicateAI

Dieser Style Guide beschreibt die Konventionen und Best Practices für Code und Dokumentation im ReplicateAI-Projekt. Die Einhaltung dieser Richtlinien gewährleistet Konsistenz, Lesbarkeit und Wartbarkeit des gesamten Projekts.

## 1. Code-Stil

### 1.1. TypeScript/JavaScript

*   **Formatierung**: Verwenden Sie Prettier für die automatische Code-Formatierung. Stellen Sie sicher, dass Ihr Editor Prettier bei jedem Speichern ausführt.
*   **Linting**: Eslint wird für die Code-Qualität und das Auffinden potenzieller Fehler verwendet. Beheben Sie alle Linting-Fehler, bevor Sie Commits pushen.
*   **Variablennamen**:
    *   Verwenden Sie `camelCase` für Variablennamen, Funktionsnamen und Methoden.
    *   Verwenden Sie `PascalCase` für Komponenten, Klassen und Typen/Interfaces.
    *   Verwenden Sie `UPPER_SNAKE_CASE` für Konstanten, die global oder auf Modulebene definiert sind.
*   **Importe**:
    *   Gruppieren Sie Importe:
        1.  Node.js-Module (z.B. `path`)
        2.  Drittanbieter-Bibliotheken (z.B. `react`, `next`)
        3.  Projekt-Aliase (z.B. `@/components`, `@/lib`)
        4.  Relative Importe (z.B. `./utils`)
    *   Sortieren Sie Importe alphabetisch innerhalb jeder Gruppe.
*   **Funktionen**:
    *   Verwenden Sie Pfeilfunktionen für Komponenten und Callbacks.
    *   Benennen Sie Funktionen aussagekräftig.
*   **Kommentare**:
    *   Verwenden Sie JSDoc-Kommentare für Funktionen, Klassen und komplexe Logik.
    *   Kurze Erklärungen können mit `//` kommentiert werden.
    *   Vermeiden Sie redundante Kommentare, die den Code nur wiederholen.

### 1.2. React/Next.js

*   **Komponenten**:
    *   Verwenden Sie Funktionskomponenten.
    *   Benennen Sie Komponenten mit `PascalCase` und speichern Sie sie in Dateien mit dem gleichen Namen (z.B. `MyComponent.tsx`).
    *   Verwenden Sie `useState`, `useEffect`, `useCallback`, `useMemo` und `useRef` Hooks nach Bedarf.
    *   Props sollten klar typisiert sein.
*   **Styling**:
    *   Verwenden Sie Tailwind CSS für das Styling.
    *   Bevorzugen Sie Utility-Klassen gegenüber Inline-Styles.
    *   Verwenden Sie `clsx` oder `tailwind-merge` für bedingtes Styling.
*   **API-Routen**:
    *   Verwenden Sie Next.js API Routes für serverseitige Logik.
    *   Stellen Sie sicher, dass die Routen RESTful sind.
    *   Behandeln Sie Fehler ordnungsgemäß und geben Sie aussagekräftige Statuscodes zurück.

### 1.3. Git-Commits

*   **Commit-Nachrichten**: Verwenden Sie das [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) Format.
    *   `type(scope): subject`
    *   **Typen**: `feat` (Feature), `fix` (Bugfix), `docs` (Dokumentation), `style` (Formatierung), `refactor` (Refactoring), `test` (Tests), `chore` (Wartung), `perf` (Performance).
    *   **Scope**: Optional, beschreibt den Bereich der Änderung (z.B. `chat`, `api`, `supabase`).
    *   **Subject**: Kurze, prägnante Beschreibung der Änderung im Präsens.
*   **Beispiele**:
    *   `feat(chat): Add Supabase integration for messages`
    *   `fix(api): Correct webhook error handling`
    *   `docs(contributing): Update style guide`

## 2. Dokumentations-Stil

*   **Markdown**: Alle Dokumentationsdateien sollten im Markdown-Format (`.md`) geschrieben sein.
*   **Klarheit und Prägnanz**: Schreiben Sie klar, prägnant und direkt. Vermeiden Sie Jargon, wo immer möglich.
*   **Konsistenz**:
    *   Verwenden Sie eine konsistente Terminologie.
    *   Halten Sie sich an die [Diátaxis-Struktur](https://diataxis.fr/) (Tutorials, How-To Guides, Reference, Explanation).
*   **Code-Blöcke**: Verwenden Sie dreifache Backticks (``````) für Code-Blöcke und geben Sie die Sprache an (z.B. ````javascript`).
*   **Bilder und Videos**: Speichern Sie alle visuellen Assets im `docs/assets/` Verzeichnis und verlinken Sie sie entsprechend.
*   **Links**: Verwenden Sie relative Links für interne Dokumente.
*   **Überschriften**: Verwenden Sie `#` für Hauptüberschriften, `##` für Unterüberschriften usw.

## 3. Design-Prinzipien

*   **Farbpalette**:
    *   Primärfarbe: `#4285F4` (Calm Blue)
    *   Hintergrundfarbe: `#F5F5F5` (Light Gray)
    *   Akzentfarbe: `#67B965` (Soft Muted Green)
*   **Typografie**:
    *   Body und Headline Font: 'Inter', sans-serif
    *   Code Font: 'Source Code Pro'
*   **Icons**: Verwenden Sie [Lucide Icons](https://lucide.dev/).
*   **Animationen**: Subtile Animationen mit Framer Motion für Ladezustände und Interaktionen. Keine Seitenübergänge, nur Fades, Scales und Slides.

Durch die Einhaltung dieser Richtlinien stellen wir sicher, dass ReplicateAI ein qualitativ hochwertiges, konsistentes und gut dokumentiertes Projekt bleibt.# KI-Intelligenz und Tool-Auswahl in ReplicateAI

Das Herzstück der intelligenten Funktionalität von ReplicateAI ist der `intelligentWebhookFlow`, ein KI-Agent, der darauf trainiert ist, die Absicht des Benutzers zu verstehen und das am besten geeignete Tool oder die beste Fähigkeit auszuwählen, um eine Aufgabe zu erfüllen. Dieses Dokument beschreibt, wie diese KI-Intelligenz funktioniert.

## 1. Der `intelligentWebhookFlow`

Der `intelligentWebhookFlow` ist ein Genkit AI Flow, der die Kernlogik für die Tool-Auswahl kapselt. Er nimmt eine Benutzernachricht entgegen und gibt den Namen des ausgewählten Tools sowie eine Begründung für diese Auswahl zurück.

*   **Definition**: Definiert in [`src/ai/flows/intelligent-webhooks.ts`](src/ai/flows/intelligent-webhooks.ts).
*   **Input Schema (`IntelligentWebhookInputSchema`)**: Erwartet ein Objekt mit einer `message`-Eigenschaft (der Text der Benutzernachricht).
*   **Output Schema (`IntelligentWebhookOutputSchema`)**: Gibt ein Objekt mit `toolSelected` (Name des Tools) und `reasoning` (Begründung der KI) zurück.

## 2. Das `toolSelectionPrompt`

Der `intelligentWebhookFlow` nutzt ein Prompt-Template namens `toolSelectionPrompt`, um das zugrunde liegende große Sprachmodell (LLM) anzuweisen, die Tool-Auswahl durchzuführen.

*   **Zweck**: Leitet das LLM an, die Benutzernachricht zu analysieren und eine Entscheidung über das passende Tool zu treffen.
*   **Prompt-Inhalt**: Der Prompt enthält:
    *   Eine Rolle für die KI ("FlowHero, ein KI-Assistent, der intelligent das am besten geeignete Tool oder die beste Fähigkeit auswählt...").
    *   Eine Liste der verfügbaren Tools/Capabilities mit Beispielen für deren Anwendungsfälle.
    *   Die Anweisung, das am besten geeignete Tool basierend auf der "Task Description" des Benutzers zu bestimmen.
    *   Das gewünschte JSON-Ausgabeformat (`toolSelected` und `reasoning`).

### Beispiel für Prompt-Logik

Wenn der Benutzer eine Nachricht wie "Analysiere die Verkaufszahlen des letzten Quartals und finde die umsatzstärksten Produkte." eingibt, wird der Prompt das LLM dazu anleiten, dies als eine Aufgabe zur "Datenanalyse" zu erkennen.

## 3. Verfügbare Tools/Capabilities

Die KI ist darauf trainiert, zwischen den folgenden vordefinierten Tools zu unterscheiden:

*   **"DataAnalysis"**: Für Aufgaben, die die Analyse von Datensätzen, Tabellen, das Erkennen von Trends oder das Generieren von Erkenntnissen aus Daten beinhalten.
    *   *Beispiel*: "Analysiere die Verkaufszahlen des letzten Quartals und finde die umsatzstärksten Produkte."
*   **"ContentGeneration"**: Für Aufgaben, die das Schreiben von Texten beinhalten, wie das Verfassen von E-Mails, das Erstellen von Marketingtexten, das Zusammenfassen von Dokumenten oder das Schreiben von Artikeln.
    *   *Beispiel*: "Entwerfe eine E-Mail an einen Kunden über ein Projekt-Update."
*   **"CodeExecution"**: Für Aufgaben, die das Schreiben oder Ausführen von Skripten erfordern, wie Python für die Datenmanipulation oder ein Shell-Skript für die Automatisierung.
    *   *Beispiel*: "Schreibe ein Python-Skript, um CSV in JSON zu konvertieren."
*   **"FileManagement"**: Für Aufgaben im Zusammenhang mit Dateivorgängen wie Konvertierung, Organisation oder Extraktion.
    *   *Beispiel*: "Konvertiere diese DOCX-Datei in PDF."
*   **"Research"**: Für Aufgaben, die das Sammeln von Informationen, das Finden von Fakten oder das Erforschen von Themen erfordern.
    *   *Beispiel*: "Recherchiere die neuesten Fortschritte in der KI."
*   **"Planning"**: Für Aufgaben, die das Erstellen von Zeitplänen, Reiserouten oder Projektplänen beinhalten.
    *   *Beispiel*: "Plane eine 3-tägige Reise nach Paris."
*   **"GeneralTask"**: Für allgemeine Anfragen, die nicht eindeutig in andere Kategorien passen oder einen mehrstufigen Ansatz erfordern.
    *   *Beispiel*: "Hilf mir, meine bevorstehende Marketingkampagne zu organisieren."

## 4. Integration mit Webhooks

Nachdem die KI ein Tool ausgewählt hat, kann der `intelligentWebhookFlow` einen HTTP POST-Request an eine konfigurierte n8n-Webhook-URL senden. Dieser Webhook enthält die von der KI getroffene Entscheidung (`toolSelected` und `reasoning`).

*   **Zweck**: Ermöglicht die Auslösung externer Workflows und die Integration mit Drittanbieterdiensten basierend auf der KI-Entscheidung.
*   **Konfiguration**: Die n8n-Webhook-URL wird über die Umgebungsvariable `N8N_WEBHOOK_URL` bereitgestellt.
*   **Vorteil**: Entkoppelt die KI-Logik von der tatsächlichen Tool-Ausführung, was eine hohe Flexibilität und Erweiterbarkeit ermöglicht. n8n kann dann die spezifische Logik für jedes Tool implementieren.

Diese Architektur ermöglicht es ReplicateAI, auf intelligente Weise auf eine Vielzahl von Benutzeranfragen zu reagieren, indem es die Leistungsfähigkeit von LLMs mit flexiblen Workflow-Automatisierungstools kombiniert.# Architektur von ReplicateAI

ReplicateAI ist eine moderne Webanwendung, die auf dem Next.js-Framework basiert und eine intelligente Chat-Schnittstelle mit KI-gesteuerter Tool-Auswahl und Webhook-Integration bietet. Die Architektur ist modular aufgebaut, um Skalierbarkeit, Wartbarkeit und Erweiterbarkeit zu gewährleisten.

## 1. Überblick der Hauptkomponenten

```mermaid
graph TD
    A[Client (Next.js Frontend)] --> B[Next.js API Routes]
    B --> C[Genkit AI Flows]
    B --> D[Supabase Database]
    C --> E[External Webhooks (n8n)]
    D --> F[Supabase Storage (Optional)]
    
    subgraph "Next.js Application"
        B
        C
        D
    end
    
    subgraph "External Services"
        E
        F
    end
    
    A -- "User Input" --> B
    B -- "API Calls" --> C
    C -- "Tool Selection" --> E
    B -- "Data Persistence" --> D
    D -- "File Storage" --> F
```

### 1.1. Client (Next.js Frontend)

Das Frontend ist eine Single-Page Application (SPA), die mit React und Next.js entwickelt wurde. Es bietet die Benutzeroberfläche für den Chat, die Nachrichtenanzeige, die Eingabefelder und die Dateivorschau.

*   **Technologien**: React, Next.js, Tailwind CSS, Shadcn/ui, Framer Motion
*   **Hauptkomponenten**:
    *   `ChatArea.tsx`: Verwaltet den Zustand des Chats, lädt Nachrichten und sendet Benutzereingaben.
    *   `MessageList.tsx`: Zeigt die Chat-Nachrichten an.
    *   `MessageInput.tsx`: Ermöglicht die Texteingabe und den Dateiupload.
    *   UI-Komponenten (`src/components/ui`): Wiederverwendbare UI-Elemente.

### 1.2. Next.js API Routes

Next.js API Routes dienen als Backend-for-Frontend (BFF) und als Schnittstelle zu externen Diensten wie Genkit AI und Supabase. Sie ermöglichen serverseitige Logik und den Schutz von API-Schlüsseln.

*   **Dateien**:
    *   `src/app/api/webhook/route.ts`: Verarbeitet eingehende Webhook-Anfragen und leitet sie an den Genkit AI Flow weiter.
    *   `src/app/api/messages/route.ts`: Verwaltet das Speichern und Laden von Chat-Nachrichten aus Supabase.
    *   `src/app/api/settings/route.ts`: Stellt Anwendungseinstellungen bereit (z.B. Begrüßungsnachricht).

### 1.3. Genkit AI Flows

Genkit ist ein Open-Source-Framework von Google, das die Entwicklung von KI-gesteuerten Anwendungen vereinfacht. In ReplicateAI wird Genkit verwendet, um die intelligente Tool-Auswahl zu implementieren.

*   **Dateien**:
    *   `src/ai/genkit.ts`: Genkit-Konfiguration.
    *   `src/ai/flows/intelligent-webhooks.ts`: Definiert den AI-Flow, der basierend auf der Benutzereingabe das am besten geeignete Tool auswählt und optional einen Webhook an n8n sendet.
    *   `src/ai/dev.ts`: Entwicklungs-Konfiguration für Genkit.

### 1.4. Supabase Database

Supabase wird als Backend-as-a-Service (BaaS) für die Persistenz von Chat-Nachrichten verwendet. Es bietet eine PostgreSQL-Datenbank, Authentifizierung und Echtzeit-Funktionen.

*   **Konfiguration**: Umgebungsvariablen (`NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY`, `SUPABASE_SERVICE_ROLE_KEY`).
*   **Schema**: Die `messages`-Tabelle speichert alle Chat-Nachrichten mit Metadaten.
*   **Client**: `src/lib/supabase.ts` initialisiert den Supabase-Client.

### 1.5. External Webhooks (n8n)

n8n ist ein Workflow-Automatisierungstool, das als Ziel für die von Genkit AI ausgelösten Webhooks dient. Es ermöglicht die flexible Integration mit einer Vielzahl von Drittanbieterdiensten basierend auf der von der KI getroffenen Tool-Auswahl.

*   **Konfiguration**: `N8N_WEBHOOK_URL` in der `.env`-Datei.
*   **Funktion**: Empfängt die von `intelligentWebhook` gesendeten Daten und kann daraufhin weitere Aktionen auslösen (z.B. Datenanalyse, Content-Generierung, Code-Ausführung).

### 1.6. Supabase Storage (Optional)

Für die Dateiverwaltung kann Supabase Storage verwendet werden, um hochgeladene Dateien zu speichern und temporäre Links für die Vorschau im Chat bereitzustellen. Dies ist derzeit optional und kann bei Bedarf erweitert werden.

## 2. Datenfluss

1.  **Benutzereingabe**: Der Benutzer gibt eine Nachricht in das Chat-Eingabefeld ein.
2.  **Nachricht speichern**: Die Nachricht wird an die Next.js API-Route `/api/messages` gesendet und in der Supabase-Datenbank gespeichert.
3.  **AI-Verarbeitung**: Die Benutzernachricht wird an den `intelligentWebhook` Genkit AI Flow gesendet.
4.  **Tool-Auswahl**: Der AI Flow analysiert die Nachricht und wählt das am besten geeignete Tool aus (z.B. "DataAnalysis", "ContentGeneration").
5.  **Webhook-Auslösung**: Basierend auf der Tool-Auswahl sendet der AI Flow optional einen Webhook an die konfigurierte n8n-URL mit den relevanten Daten.
6.  **AI-Antwort**: Der AI Flow gibt eine simulierte Antwort zurück, die im Chat angezeigt wird.
7.  **Nachrichtenanzeige**: Alle Nachrichten (Benutzer, Assistent, System) werden aus Supabase geladen und im `MessageList` angezeigt.

## 3. Skalierbarkeit und Erweiterbarkeit

*   **Modulare Komponenten**: Ermöglicht die einfache Entwicklung und Wartung einzelner Teile der Anwendung.
*   **API-zentriert**: Klare Trennung von Frontend und Backend.
*   **Genkit AI**: Einfache Erweiterung um neue Tools und AI-Modelle.
*   **Supabase**: Skalierbare Datenbank und Backend-Dienste.
*   **n8n**: Flexible Integration mit unzähligen externen Diensten und Workflows.

Diese Architektur bietet eine robuste Grundlage für eine intelligente und erweiterbare Chat-Anwendung.# Webhook-System in ReplicateAI

Das Webhook-System in ReplicateAI ermöglicht die Kommunikation zwischen der Anwendung und externen Diensten, insbesondere für die Ausführung von Aktionen, die durch die KI-gesteuerte Tool-Auswahl initiiert werden. Es besteht aus zwei Hauptteilen: einem eingehenden Webhook-Endpunkt für die Anwendung und einem ausgehenden Webhook, der von der KI ausgelöst wird.

## 1. Eingehender Webhook-Endpunkt (`/api/webhook`)

ReplicateAI stellt einen eigenen API-Endpunkt bereit, der als Webhook-Empfänger fungieren kann. Dieser Endpunkt ist dafür konzipiert, externe Anfragen zu verarbeiten und die `intelligentWebhook`-Funktion auszulösen.

*   **Zweck**: Ermöglicht es externen Systemen (z.B. n8n, andere Automatisierungstools), Anfragen an ReplicateAI zu senden, um die KI-Logik zu initiieren.
*   **Route**: [`src/app/api/webhook/route.ts`](src/app/api/webhook/route.ts)
*   **Methode**: `POST`
*   **Erwarteter Request Body**: Ein JSON-Objekt mit einer `message`-Eigenschaft, die den Text der Benutzereingabe enthält.
    ```json
    {
      "message": "Analysiere die Verkaufsdaten für das letzte Quartal."
    }
    ```
*   **Funktionsweise**:
    1.  Empfängt eine POST-Anfrage.
    2.  Extrahiert die `message` aus dem Request Body.
    3.  Ruft die `intelligentWebhook`-Funktion auf, um die KI-Tool-Auswahl durchzuführen.
    4.  Gibt das Ergebnis der KI-Auswahl als JSON-Antwort zurück.
*   **Fehlerbehandlung**: Der Endpunkt enthält grundlegende Fehlerbehandlung für fehlende Nachrichten oder interne Serverfehler.

## 2. Ausgehender Webhook (n8n-Integration)

Nachdem der `intelligentWebhookFlow` ein Tool ausgewählt hat, kann er einen ausgehenden Webhook an eine konfigurierte n8n-URL senden. Dies ist der Mechanismus, um die KI-Entscheidung an ein Workflow-Automatisierungstool zu übergeben, das dann die eigentliche Aktion ausführen kann.

*   **Auslöser**: Erfolgreiche Tool-Auswahl durch den `intelligentWebhookFlow`.
*   **Konfiguration**: Die Ziel-URL für den ausgehenden Webhook wird über die Umgebungsvariable `N8N_WEBHOOK_URL` in der `.env`-Datei definiert.
    ```env
    N8N_WEBHOOK_URL=https://flowherodemo.app.n8n.cloud/webhook-test/test
    ```
*   **Gesendeter Request Body**: Der Webhook sendet ein JSON-Objekt, das die Ausgabe des KI-Flows enthält:
    ```json
    {
      "toolSelected": "DataAnalysis",
      "reasoning": "The user's request clearly indicates a need to analyze sales figures, which falls under data analysis."
    }
    ```
*   **Implementierung**: Die Logik für das Senden des Webhooks ist in [`src/ai/flows/intelligent-webhooks.ts`](src/ai/flows/intelligent-webhooks.ts) innerhalb des `intelligentWebhookFlow` implementiert.
    ```typescript
    // Auszug aus intelligent-webhooks.ts
    const n8nWebhookUrl = process.env.N8N_WEBHOOK_URL;
    if (n8nWebhookUrl) {
      try {
        await fetch(n8nWebhookUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(output), // 'output' enthält toolSelected und reasoning
        });
        console.log('Webhook sent to n8n successfully.');
      } catch (error) {
        console.error('Failed to send webhook to n8n:', error);
      }
    }
    ```
*   **Vorteile der n8n-Integration**:
    *   **Flexibilität**: n8n kann eine Vielzahl von Aktionen ausführen, von der Interaktion mit APIs bis zur Datenverarbeitung, basierend auf der empfangenen Tool-Auswahl.
    *   **Entkopplung**: Die KI-Logik bleibt sauber und muss keine spezifischen Implementierungsdetails für jedes Tool kennen.
    *   **Visuelle Workflows**: n8n bietet eine grafische Oberfläche zum Erstellen und Verwalten komplexer Workflows.

## 3. Anwendungsfälle

*   **Automatisierte Aufgaben**: Die KI wählt ein Tool, und n8n führt eine automatisierte Aufgabe aus (z.B. E-Mail-Versand, Datenbank-Update).
*   **Datenverarbeitung**: Die KI erkennt eine Datenanalyse-Anfrage, sendet einen Webhook an n8n, und n8n startet einen Datenanalyse-Workflow.
*   **Benachrichtigungen**: Nach einer bestimmten KI-Aktion kann n8n eine Benachrichtigung an Slack, Teams oder andere Kommunikationskanäle senden.

Das Webhook-System ist ein entscheidender Bestandteil von ReplicateAI, der die Brücke zwischen der intelligenten KI und der Ausführung realer Aktionen schlägt.# Kernkonzepte von ReplicateAI

Dieses Dokument erklärt die grundlegenden Konzepte und Terminologien, die in der ReplicateAI-Anwendung verwendet werden. Ein klares Verständnis dieser Konzepte ist entscheidend, um die Funktionsweise des Systems zu verstehen und effektiv damit zu arbeiten.

## 1. Chat-Nachricht (Message)

Eine `Message` ist die grundlegende Einheit der Kommunikation im ReplicateAI-Chat. Jede Nachricht hat folgende Eigenschaften:

*   **`id`**: Eine eindeutige Kennung für die Nachricht.
*   **`text`**: Der eigentliche Inhalt der Nachricht.
*   **`sender`**: Gibt an, wer die Nachricht gesendet hat (`user`, `assistant`, oder `system`).
*   **`timestamp`**: Der Zeitpunkt, zu dem die Nachricht erstellt wurde.
*   **`file` (optional)**: Ein Objekt, das Details zu einer angehängten Datei enthält (z.B. Name, Typ, URL).
*   **`reasoning` (optional)**: Eine Begründung, die von der KI geliefert wird, wenn sie eine Tool-Auswahl trifft.

Nachrichten werden in der Supabase-Datenbank gespeichert, um die Persistenz des Chat-Verlaufs zu gewährleisten.

## 2. Intelligente Webhooks (Intelligent Webhook Flow)

Dies ist das Herzstück der KI-gesteuerten Funktionalität von ReplicateAI. Der "Intelligent Webhook Flow" ist ein Genkit AI Flow, der die Benutzereingabe analysiert und basierend auf dem Inhalt die am besten geeignete "Tool/Capability" auswählt.

*   **Zweck**: Automatische Erkennung der Benutzerabsicht und Auswahl des passenden Tools.
*   **Input**: Die Textnachricht des Benutzers.
*   **Output**: Der Name des ausgewählten Tools (`toolSelected`) und eine Begründung (`reasoning`).
*   **Integration**: Nach der Tool-Auswahl kann der Flow einen externen Webhook (z.B. an n8n) auslösen, um die tatsächliche Ausführung des Tools zu initiieren.

## 3. Tools/Capabilities

Dies sind die vordefinierten Kategorien von Aufgaben, die die ReplicateAI-KI erkennen und zuordnen kann. Jedes Tool repräsentiert eine bestimmte Art von Aktion oder Funktionalität, die von der Anwendung oder einem externen Dienst ausgeführt werden kann.

Aktuell definierte Tools:

*   `DataAnalysis`
*   `ContentGeneration`
*   `CodeExecution`
*   `FileManagement`
*   `Research`
*   `Planning`
*   `GeneralTask`

Die KI wählt eines dieser Tools basierend auf der `message` des Benutzers aus.

## 4. Supabase

Supabase ist eine Open-Source-Alternative zu Firebase, die als Backend-as-a-Service (BaaS) für ReplicateAI dient. Es bietet:

*   **PostgreSQL-Datenbank**: Für die Speicherung von Chat-Nachrichten und anderen Anwendungsdaten.
*   **Echtzeit-Funktionen**: Ermöglicht Live-Updates im Chat (zukünftiges Feature).
*   **Authentifizierung**: Für die Benutzerverwaltung (zukünftiges Feature).
*   **Speicher (Storage)**: Zum Speichern von Dateien (optional für Dateianhänge).

## 5. n8n (Node-based Workflow Automation)

n8n ist ein leistungsstarkes Open-Source-Tool zur Workflow-Automatisierung. In ReplicateAI wird n8n als flexibler Endpunkt für die von der KI ausgelösten Webhooks verwendet.

*   **Zweck**: Ermöglicht die Verbindung der KI-Tool-Auswahl mit einer Vielzahl von externen Diensten und die Ausführung komplexer Workflows.
*   **Funktionsweise**: Wenn der `intelligentWebhook` Flow ein Tool auswählt, sendet er eine Anfrage an eine konfigurierte n8n-Webhook-URL. n8n kann dann basierend auf der empfangenen Tool-Auswahl weitere Aktionen ausführen (z.B. eine E-Mail senden, eine API aufrufen, Daten verarbeiten).

## 6. Umgebungsvariablen

Wichtige Konfigurationswerte, die außerhalb des Quellcodes gespeichert werden, um die Anwendung in verschiedenen Umgebungen (Entwicklung, Produktion) flexibel zu halten.

*   `GEMINI_API_KEY`: API-Schlüssel für das Google Gemini AI-Modell.
*   `N8N_WEBHOOK_URL`: Die URL des n8n-Webhooks, an den die KI-Auswahl gesendet wird.
*   `NEXT_PUBLIC_SUPABASE_URL`: Die URL Ihrer Supabase-Instanz (öffentlich zugänglich).
*   `NEXT_PUBLIC_SUPABASE_ANON_KEY`: Der öffentliche "Anon Key" für Supabase (öffentlich zugänglich).
*   `SUPABASE_SERVICE_ROLE_KEY`: Der Service Role Key für Supabase (nur serverseitig verwenden, um volle Datenbankzugriffe zu ermöglichen).

Diese Konzepte bilden das Fundament von ReplicateAI und ermöglichen die intelligente und erweiterbare Chat-Funktionalität.# How-To: Webhooks konfigurieren und nutzen

Dieses Dokument beschreibt, wie Sie die Webhook-Funktionalität in ReplicateAI konfigurieren und nutzen können, um die KI-gesteuerte Tool-Auswahl mit externen Diensten zu verbinden.

## 1. Ausgehende Webhooks (KI-gesteuert)

ReplicateAI kann nach der KI-gesteuerten Tool-Auswahl einen Webhook an eine externe URL senden. Dies wird typischerweise verwendet, um einen Workflow in einem Automatisierungstool wie n8n auszulösen.

### 1.1. n8n-Webhook-URL abrufen

1.  **n8n-Instanz**: Stellen Sie sicher, dass Sie eine laufende n8n-Instanz haben (lokal oder gehostet).
2.  **Neuen Workflow erstellen**: Erstellen Sie einen neuen Workflow in n8n.
3.  **Webhook-Node hinzufügen**: Fügen Sie einen "Webhook"-Node als Startpunkt des Workflows hinzu.
4.  **Webhook-URL kopieren**: Konfigurieren Sie den Webhook-Node (z.B. Methode auf `POST` setzen) und kopieren Sie die generierte "Webhook URL". Diese URL wird Ihre `N8N_WEBHOOK_URL`.

### 1.2. `N8N_WEBHOOK_URL` in `.env` konfigurieren

Öffnen Sie die `.env`-Datei in Ihrem ReplicateAI-Projekt und fügen Sie die n8n-Webhook-URL hinzu.

1.  **`.env` Datei öffnen**: Suchen Sie die `.env`-Datei im Stammverzeichnis Ihres Projekts.
2.  **Variable hinzufügen/aktualisieren**: Fügen Sie die folgende Zeile hinzu oder aktualisieren Sie sie mit Ihrer n8n-Webhook-URL:

    ```env
    N8N_WEBHOOK_URL=Ihre_n8n_Webhook_URL_hier
    ```
    *Ersetzen Sie den Platzhalter durch Ihre tatsächliche n8n-Webhook-URL.*

### 1.3. n8n-Workflow für Tool-Auswahl erstellen

In n8n können Sie einen Workflow erstellen, der auf die von ReplicateAI gesendeten Daten reagiert.

1.  **Webhook-Node**: Der Webhook-Node empfängt die Daten von ReplicateAI. Der Request Body enthält `toolSelected` und `reasoning`.
    ```json
    {
      "toolSelected": "DataAnalysis",
      "reasoning": "The user's request clearly indicates a need to analyze sales figures, which falls under data analysis."
    }
    ```
2.  **If-Node (Conditional Logic)**: Fügen Sie einen "If"-Node hinzu, um basierend auf dem Wert von `toolSelected` verschiedene Pfade zu erstellen.
    *   Beispiel: Wenn `toolSelected` "DataAnalysis" ist, führen Sie einen bestimmten Zweig des Workflows aus.
3.  **Aktions-Nodes**: Fügen Sie Nodes hinzu, die die tatsächlichen Aktionen ausführen.
    *   Für "DataAnalysis": Verbinden Sie sich mit einer Datenbank, führen Sie eine Abfrage aus, generieren Sie einen Bericht.
    *   Für "ContentGeneration": Verwenden Sie einen LLM-Node, um Text zu generieren, und senden Sie ihn an eine E-Mail oder ein CMS.
    *   Für "CodeExecution": Führen Sie ein Skript auf einem Server aus.
4.  **Workflow aktivieren**: Speichern und aktivieren Sie Ihren n8n-Workflow.

## 2. Eingehende Webhooks (ReplicateAI als Empfänger)

ReplicateAI kann auch selbst als Webhook-Empfänger fungieren. Dies ist nützlich, wenn Sie externe Systeme haben, die die KI-Logik von ReplicateAI auslösen möchten.

### 2.1. Endpunkt-URL

Der Endpunkt für eingehende Webhooks in ReplicateAI ist:

*   **URL**: `http://localhost:3000/api/webhook` (für lokale Entwicklung)
    *   In Produktion wird dies `https://ihre-domain.com/api/webhook` sein.
*   **Methode**: `POST`
*   **Request Body**: Erwartet ein JSON-Objekt mit einer `message`-Eigenschaft.
    ```json
    {
      "message": "Ihre Nachricht hier, die von der KI verarbeitet werden soll."
    }
    ```

### 2.2. Testen des eingehenden Webhooks

Sie können diesen Endpunkt mit Tools wie `curl`, Postman, Insomnia oder direkt aus einem n8n-Workflow testen.

#### Beispiel mit `curl`:

```bash
curl -X POST -H "Content-Type: application/json" -d '{"message": "Analysiere die Verkaufszahlen des letzten Quartals."}' http://localhost:3000/api/webhook
```

Die Antwort sollte ein JSON-Objekt mit `toolSelected` und `reasoning` enthalten, das von der ReplicateAI-KI generiert wurde.

Durch die Nutzung dieser Webhook-Funktionalitäten können Sie ReplicateAI nahtlos in Ihre bestehenden Automatisierungs- und Datenverarbeitungsworkflows integrieren.# How-To: Supabase einrichten und integrieren

Dieser Leitfaden führt Sie durch die Schritte zur Einrichtung einer Supabase-Datenbank und deren Integration in Ihr ReplicateAI-Projekt, um Chat-Nachrichten persistent zu speichern.

## 1. Supabase-Projekt erstellen

1.  **Registrieren oder Anmelden**: Gehen Sie zu [Supabase](https://supabase.com/) und melden Sie sich an oder erstellen Sie ein neues Konto.
2.  **Neues Projekt**: Klicken Sie auf "New project" im Dashboard.
3.  **Projektdetails**:
    *   **Name**: Geben Sie Ihrem Projekt einen aussagekräftigen Namen (z.B. `replicateai-chat`).
    *   **Datenbank-Passwort**: Legen Sie ein sicheres Passwort fest.
    *   **Region**: Wählen Sie eine Region, die Ihren Anforderungen entspricht.
4.  **Projekt erstellen**: Klicken Sie auf "Create new project".

## 2. Datenbank-Schema erstellen

Nachdem Ihr Projekt erstellt wurde, müssen Sie die `messages`-Tabelle in Ihrer Supabase-Datenbank einrichten.

1.  **SQL Editor öffnen**: Navigieren Sie im Supabase-Dashboard zu "SQL Editor" (das Icon mit dem Datenbank-Symbol).
2.  **Neues Query**: Klicken Sie auf "New query".
3.  **Schema einfügen**: Kopieren Sie das folgende SQL-Schema und fügen Sie es in den Editor ein:

    ```sql
    CREATE TABLE messages (
      id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
      text TEXT NOT NULL,
      sender VARCHAR(20) NOT NULL CHECK (sender IN ('user', 'assistant', 'system')),
      timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
      file_data JSONB,
      reasoning TEXT,
      created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    );

    -- Optional: Indizes für bessere Performance bei Abfragen
    CREATE INDEX idx_messages_timestamp ON messages(timestamp DESC);
    CREATE INDEX idx_messages_sender ON messages(sender);
    ```
4.  **Ausführen**: Klicken Sie auf "Run" (das Play-Symbol), um die Tabelle zu erstellen.

## 3. Supabase-Anmeldeinformationen abrufen

Sie benötigen die URL und die API-Schlüssel Ihres Supabase-Projekts, um die Anwendung zu verbinden.

1.  **API Settings**: Navigieren Sie im Supabase-Dashboard zu "Project Settings" (Zahnrad-Icon) und dann zu "API".
2.  **URL und Keys**: Notieren Sie sich die folgenden Werte:
    *   **`URL`**: Dies ist Ihre `NEXT_PUBLIC_SUPABASE_URL`.
    *   **`anon public`**: Dies ist Ihr `NEXT_PUBLIC_SUPABASE_ANON_KEY`.
    *   **`service_role`**: Dies ist Ihr `SUPABASE_SERVICE_ROLE_KEY`. **Halten Sie diesen Schlüssel geheim und verwenden Sie ihn nur serverseitig!**

## 4. Umgebungsvariablen in ReplicateAI konfigurieren

Öffnen Sie die `.env`-Datei in Ihrem ReplicateAI-Projekt und fügen Sie die abgerufenen Supabase-Anmeldeinformationen hinzu.

1.  **`.env` Datei öffnen**: Suchen Sie die `.env`-Datei im Stammverzeichnis Ihres Projekts.
2.  **Variablen hinzufügen/aktualisieren**: Fügen Sie die folgenden Zeilen hinzu oder aktualisieren Sie sie mit Ihren tatsächlichen Werten:

    ```env
    NEXT_PUBLIC_SUPABASE_URL=Ihre_Supabase_URL_hier
    NEXT_PUBLIC_SUPABASE_ANON_KEY=Ihr_Supabase_Anon_Key_hier
    SUPABASE_SERVICE_ROLE_KEY=Ihr_Supabase_Service_Role_Key_hier
    ```
    *Ersetzen Sie die Platzhalter durch Ihre tatsächlichen Schlüssel.*

## 5. Anwendung starten und testen

1.  **Abhängigkeiten installieren**: Stellen Sie sicher, dass Sie den Supabase-Client installiert haben:
    ```bash
    npm install @supabase/supabase-js
    ```
2.  **Anwendung starten**: Starten Sie den Entwicklungs-Server:
    ```bash
    npm run dev
    ```
3.  **Chat testen**: Öffnen Sie die Anwendung in Ihrem Browser und senden Sie einige Nachrichten im Chat. Diese sollten nun in Ihrer Supabase-Datenbank in der `messages`-Tabelle gespeichert werden. Sie können dies im Supabase-Dashboard unter "Table Editor" überprüfen.

Herzlichen Glückwunsch! Ihre ReplicateAI-Anwendung ist nun mit Supabase verbunden und speichert Chat-Nachrichten persistent.# How-To: Neue KI-Tools in ReplicateAI integrieren

Dieser Leitfaden beschreibt den Prozess der Integration neuer KI-gesteuerter Tools oder Fähigkeiten in ReplicateAI. Dies beinhaltet die Erweiterung des `intelligentWebhookFlow` und die Konfiguration von n8n, um die neuen Tools zu verarbeiten.

## 1. Überblick des Integrationsprozesses

Die Integration eines neuen Tools in ReplicateAI folgt einem dreistufigen Prozess:

1.  **Definition des Tools**: Beschreiben Sie das neue Tool und seine Anwendungsfälle im `toolSelectionPrompt`.
2.  **KI-Erkennung**: Trainieren Sie die KI (durch den Prompt), das neue Tool basierend auf Benutzereingaben zu erkennen.
3.  **Aktionsausführung**: Konfigurieren Sie n8n (oder einen anderen externen Dienst), um die tatsächliche Aktion auszuführen, wenn das Tool von der KI ausgewählt wird.

## 2. Schritt 1: `intelligent-webhooks.ts` aktualisieren

Sie müssen die Liste der verfügbaren Tools im `toolSelectionPrompt` in [`src/ai/flows/intelligent-webhooks.ts`](src/ai/flows/intelligent-webhooks.ts) erweitern.

1.  **Datei öffnen**: Öffnen Sie `src/ai/flows/intelligent-webhooks.ts`.
2.  **Tool hinzufügen**: Fügen Sie Ihr neues Tool zur Liste im `prompt`-String hinzu. Beschreiben Sie klar, wofür das Tool ist und geben Sie ein Beispiel für eine Benutzereingabe, die dieses Tool auslösen würde.

    ```typescript
    // Auszug aus src/ai/flows/intelligent-webhooks.ts
    prompt: `You are FlowHero, an AI assistant that intelligently selects the most appropriate tool or capability to fulfill a user's task request.

    You have access to the following tools/capabilities:
    ...
    - "NewToolName": For tasks involving [kurze Beschreibung des Anwendungsfalls]. Example: "[Beispiel-Benutzereingabe]."
    ...
    `,
    ```
    *Ersetzen Sie `"NewToolName"` und die Beschreibungen durch die Details Ihres neuen Tools.*

3.  **Anwendung neu starten**: Nach dem Speichern der Änderungen müssen Sie Ihren Next.js-Entwicklungs-Server neu starten, damit die Änderungen am Genkit AI Flow wirksam werden.

## 3. Schritt 2: n8n-Workflow erweitern

Nachdem die KI nun in der Lage ist, Ihr neues Tool zu erkennen, müssen Sie n8n anweisen, was zu tun ist, wenn dieses Tool ausgewählt wird.

1.  **n8n-Workflow öffnen**: Öffnen Sie den n8n-Workflow, der den Webhook von ReplicateAI empfängt (den Sie unter [How-To: Webhooks konfigurieren](configure-webhooks.md) eingerichtet haben).
2.  **If-Node erweitern**: Wenn Sie einen "If"-Node verwenden, um die `toolSelected`-Eigenschaft zu prüfen, fügen Sie eine neue Bedingung für Ihr `NewToolName` hinzu.
3.  **Neuen Workflow-Zweig erstellen**: Erstellen Sie einen neuen Zweig im Workflow, der ausgeführt wird, wenn Ihr `NewToolName` ausgewählt wird.
4.  **Aktions-Nodes hinzufügen**: Fügen Sie die erforderlichen Nodes hinzu, um die tatsächliche Aktion für Ihr neues Tool auszuführen. Dies könnte sein:
    *   Ein "HTTP Request"-Node, um eine externe API aufzurufen.
    *   Ein "Function"-Node, um benutzerdefinierten JavaScript-Code auszuführen.
    *   Ein "Database"-Node, um mit einer Datenbank zu interagieren.
    *   Ein "Email"-Node, um eine E-Mail zu senden.
    *   Jeder andere n8n-Node, der die gewünschte Funktionalität bietet.

### Beispiel für einen n8n-Workflow-Zweig für "NewToolName"

```mermaid
graph TD
    A[Webhook (ReplicateAI)] --> B{If toolSelected is "NewToolName"?}
    B -- Yes --> C[Execute NewToolName Logic]
    C --> D[API Call / Database Op / etc.]
    B -- No --> E[Continue to other tool logic]
```

## 4. Schritt 3: Testen des neuen Tools

1.  **ReplicateAI Chat**: Gehen Sie zum Chat-Interface von ReplicateAI.
2.  **Test-Nachricht senden**: Senden Sie eine Nachricht, die Ihr neues Tool auslösen sollte, basierend auf dem Beispiel, das Sie im `toolSelectionPrompt` definiert haben.
    *   Beispiel: "Bitte [Ihre Beispiel-Benutzereingabe für NewToolName]."
3.  **Überprüfen der KI-Antwort**: Im Chat sollte eine Systemnachricht erscheinen, die anzeigt, dass die KI Ihr `NewToolName` ausgewählt hat.
4.  **n8n-Workflow-Ausführung prüfen**: Überprüfen Sie in Ihrer n8n-Instanz den Ausführungsverlauf des Workflows. Sie sollten sehen, dass der Webhook von ReplicateAI empfangen wurde und der Zweig für Ihr `NewToolName` ausgeführt wurde.

Durch diese Schritte können Sie die Fähigkeiten von ReplicateAI erweitern, indem Sie neue KI-gesteuerte Tools integrieren und diese mit leistungsstarken Automatisierungsworkflows verbinden.# How-To: ReplicateAI in Produktion bereitstellen

Dieser Leitfaden beschreibt die Schritte zur Bereitstellung Ihrer ReplicateAI-Anwendung in einer Produktionsumgebung. Da ReplicateAI auf Next.js basiert, ist Vercel eine empfohlene Plattform für das Deployment, aber die Prinzipien können auf andere Node.js-Hosting-Anbieter übertragen werden.

## 1. Vorbereitung für das Deployment

Bevor Sie Ihre Anwendung bereitstellen, stellen Sie sicher, dass die folgenden Punkte erfüllt sind:

*   **Umgebungsvariablen**: Alle erforderlichen Umgebungsvariablen (`.env`) müssen für die Produktionsumgebung konfiguriert sein. Dazu gehören:
    *   `GEMINI_API_KEY`
    *   `N8N_WEBHOOK_URL`
    *   `NEXT_PUBLIC_SUPABASE_URL`
    *   `NEXT_PUBLIC_SUPABASE_ANON_KEY`
    *   `SUPABASE_SERVICE_ROLE_KEY` (Dieser sollte nur serverseitig verfügbar sein und nicht im Frontend exponiert werden).
*   **Supabase-Setup**: Stellen Sie sicher, dass Ihre Supabase-Datenbank korrekt eingerichtet ist und die `messages`-Tabelle existiert (siehe [How-To: Supabase einrichten](setup-supabase.md)).
*   **Build-Optimierung**: Next.js optimiert den Build-Prozess automatisch für die Produktion.

## 2. Deployment mit Vercel (Empfohlen)

Vercel ist die Plattform, die von den Entwicklern von Next.js empfohlen wird und eine nahtlose Bereitstellung ermöglicht.

1.  **Vercel-Konto erstellen**: Wenn Sie noch keines haben, erstellen Sie ein kostenloses Vercel-Konto unter [vercel.com](https://vercel.com/).
2.  **Neues Projekt importieren**:
    *   Melden Sie sich bei Vercel an.
    *   Klicken Sie auf "Add New..." und dann auf "Project".
    *   Importieren Sie Ihr Git-Repository (GitHub, GitLab, Bitbucket), das Ihr ReplicateAI-Projekt enthält.
3.  **Projekt konfigurieren**:
    *   Vercel erkennt automatisch, dass es sich um ein Next.js-Projekt handelt.
    *   **Umgebungsvariablen**: Gehen Sie zu den "Environment Variables" in den Projekteinstellungen. Fügen Sie hier alle oben genannten Umgebungsvariablen hinzu. Stellen Sie sicher, dass sensible Schlüssel wie `SUPABASE_SERVICE_ROLE_KEY` als "Serverless Function (Node.js)" oder "Edge Function" Variablen markiert sind, um sie vor dem Client zu schützen.
    *   **Build & Output Settings**: Normalerweise sind die Standardeinstellungen für Next.js ausreichend.
4.  **Bereitstellen**: Klicken Sie auf "Deploy". Vercel wird Ihr Projekt bauen und bereitstellen. Nach erfolgreichem Deployment erhalten Sie eine öffentliche URL für Ihre Anwendung.

## 3. Deployment auf anderen Plattformen

Wenn Sie eine andere Hosting-Plattform verwenden möchten, müssen Sie sicherstellen, dass diese Node.js-Anwendungen hosten kann und die folgenden Anforderungen erfüllt:

*   **Node.js-Umgebung**: Die Plattform muss eine Node.js-Laufzeitumgebung bereitstellen.
*   **Build-Prozess**: Sie müssen den Next.js-Build-Befehl (`npm run build`) ausführen und die generierten statischen Assets und Server-Bundles bereitstellen.
*   **Umgebungsvariablen**: Die Plattform muss die Möglichkeit bieten, Umgebungsvariablen sicher zu konfigurieren.
*   **Port-Exposition**: Stellen Sie sicher, dass die Anwendung auf dem richtigen Port lauscht und dieser öffentlich zugänglich ist.
*   **Reverse Proxy**: Ein Reverse Proxy (z.B. Nginx, Caddy) kann erforderlich sein, um Anfragen an Ihre Next.js-Anwendung weiterzuleiten.

### Allgemeine Schritte für andere Plattformen:

1.  **Build erstellen**: Führen Sie lokal oder auf Ihrem CI/CD-Server den Build-Befehl aus:
    ```bash
    npm run build
    ```
    Dies erstellt den `.next`-Ordner mit den Produktions-Assets.
2.  **Abhängigkeiten installieren**: Stellen Sie sicher, dass alle `dependencies` aus `package.json` auf dem Server installiert sind.
3.  **Umgebungsvariablen setzen**: Konfigurieren Sie die Umgebungsvariablen auf Ihrer Hosting-Plattform.
4.  **Anwendung starten**: Starten Sie die Next.js-Anwendung im Produktionsmodus:
    ```bash
    npm run start
    ```
    Dies startet einen Node.js-Server, der die Next.js-Anwendung bedient.
5.  **Prozess-Manager**: Verwenden Sie einen Prozess-Manager wie PM2 oder systemd, um sicherzustellen, dass Ihre Anwendung im Falle eines Absturzes neu gestartet wird und im Hintergrund läuft.

## 4. Nach dem Deployment

*   **Testen**: Überprüfen Sie alle Funktionen Ihrer Anwendung in der Produktionsumgebung, insbesondere die Chat-Funktionalität, die KI-Tool-Auswahl und die Webhook-Integration.
*   **Monitoring**: Richten Sie Monitoring und Logging ein, um die Leistung und Fehler Ihrer Anwendung zu überwachen.
*   **CI/CD**: Erwägen Sie die Einrichtung einer Continuous Integration/Continuous Deployment (CI/CD)-Pipeline, um den Bereitstellungsprozess zu automatisieren.

Durch die Befolgung dieser Schritte können Sie Ihre ReplicateAI-Anwendung erfolgreich in einer Produktionsumgebung bereitstellen.# API-Referenz: Nachrichten-Endpunkt

Dieser Abschnitt beschreibt die API-Endpunkte für die Verwaltung von Chat-Nachrichten in ReplicateAI. Diese Endpunkte interagieren direkt mit der Supabase-Datenbank, um Nachrichten zu speichern und abzurufen.

## 1. Nachrichten abrufen (GET)

Ruft alle gespeicherten Chat-Nachrichten ab.

*   **URL**: `/api/messages`
*   **Methode**: `GET`
*   **Beschreibung**: Gibt eine Liste aller Chat-Nachrichten in chronologischer Reihenfolge zurück.

### Request

Keine spezifischen Request Body oder Query-Parameter erforderlich.

### Response

### Erfolgreiche Response (Status: 200 OK)

Gibt ein Array von `Message`-Objekten zurück.

**Beispiel Erfolgreiche Response:**

```json
[
  {
    "id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
    "text": "Hello! I'm FlowHero. How can I assist you today?",
    "sender": "assistant",
    "timestamp": "2023-10-27T10:00:00.000Z",
    "file": null,
    "reasoning": null
  },
  {
    "id": "b2c3d4e5-f6a7-8901-2345-67890abcdef0",
    "text": "Can you help me analyze some data?",
    "sender": "user",
    "timestamp": "2023-10-27T10:01:00.000Z",
    "file": null,
    "reasoning": null
  }
]
```

### Fehler-Response (Status: 500 Internal Server Error)

Im Falle eines Fehlers wird ein JSON-Objekt mit einer `error`-Eigenschaft zurückgegeben.

```json
{
  "error": "Error fetching messages: Database connection failed."
}
```

## 2. Nachricht speichern (POST)

Speichert eine neue Chat-Nachricht in der Datenbank.

*   **URL**: `/api/messages`
*   **Methode**: `POST`
*   **Beschreibung**: Fügt eine neue Nachricht zur `messages`-Tabelle in Supabase hinzu.

### Request

### Header

*   `Content-Type: application/json` (Erforderlich)

### Body

Der Request Body muss ein JSON-Objekt sein, das dem `Message`-Typ entspricht.

| Feld        | Typ        | Beschreibung                               | Erforderlich |
| :---------- | :--------- | :----------------------------------------- | :----------- |
| `id`        | `string`   | Eindeutige Kennung der Nachricht (UUID).   | Ja           |
| `text`      | `string`   | Der Inhalt der Nachricht.                  | Ja           |
| `sender`    | `'user' \| 'assistant' \| 'system'` | Wer die Nachricht gesendet hat. | Ja           |
| `timestamp` | `string`   | Der Zeitpunkt der Nachricht (ISO 8601 String). | Ja           |
| `file`      | `object`   | (Optional) Details zu einer angehängten Datei. | Nein         |
| `reasoning` | `string`   | (Optional) Begründung der KI für die Tool-Auswahl. | Nein         |

**Beispiel Request Body:**

```json
{
  "id": "c3d4e5f6-a7b8-9012-3456-7890abcdef01",
  "text": "Based on your request, I've selected the 'DataAnalysis' tool.",
  "sender": "assistant",
  "timestamp": "2023-10-27T10:02:00.000Z",
  "reasoning": "The user's query indicated a need for data analysis."
}
```

### Response

### Erfolgreiche Response (Status: 201 Created)

Gibt das gespeicherte `Message`-Objekt zurück.

**Beispiel Erfolgreiche Response:**

```json
{
  "id": "c3d4e5f6-a7b8-9012-3456-7890abcdef01",
  "text": "Based on your request, I've selected the 'DataAnalysis' tool.",
  "sender": "assistant",
  "timestamp": "2023-10-27T10:02:00.000Z",
  "file_data": null,
  "reasoning": "The user's query indicated a need for data analysis.",
  "created_at": "2023-10-27T10:02:00.000Z"
}
```

### Fehler-Response (Status: 500 Internal Server Error)

Im Falle eines Fehlers wird ein JSON-Objekt mit einer `error`-Eigenschaft zurückgegeben.

```json
{
  "error": "Error inserting message: Database write failed."
}
```

Diese API-Endpunkte bilden die Grundlage für die persistente Speicherung und den Abruf von Chat-Nachrichten in ReplicateAI.# API-Referenz: Einstellungen-Endpunkt

Dieser Abschnitt beschreibt den API-Endpunkt für das Abrufen von Anwendungseinstellungen in ReplicateAI.

## Endpunkt-Details

*   **URL**: `/api/settings`
*   **Methode**: `GET`
*   **Beschreibung**: Ruft allgemeine Anwendungseinstellungen ab, wie z.B. die Begrüßungsnachricht des Chats.

## Request

### Header

Keine spezifischen Header erforderlich.

### Body

Kein Request Body erforderlich.

## Response

Der Endpunkt gibt ein JSON-Objekt zurück, das die Anwendungseinstellungen enthält.

### Erfolgreiche Response (Status: 200 OK)

| Feld              | Typ      | Beschreibung                               |
| :---------------- | :------- | :----------------------------------------- |
| `greetingMessage` | `string` | Die Begrüßungsnachricht, die im Chat angezeigt wird. |

**Beispiel Erfolgreiche Response:**

```json
{
  "greetingMessage": "Hello! Welcome to ReplicateAI. How can I assist you today?"
}
```

### Fehler-Response (Status: 500 Internal Server Error)

Im Falle eines Fehlers wird ein JSON-Objekt mit einer `error`-Eigenschaft zurückgegeben.

```json
{
  "error": "Internal Server Error"
}
```

## Beispiel mit `curl`

```bash
curl -X GET http://localhost:3000/api/settings
```

Dieser Endpunkt ist einfach gehalten und dient dazu, grundlegende Konfigurationen für das Frontend bereitzustellen.# API-Referenz: Webhook-Endpunkt

Dieser Abschnitt beschreibt den eingehenden Webhook-Endpunkt von ReplicateAI, der es externen Systemen ermöglicht, die KI-Logik der Anwendung auszulösen.

## Endpunkt-Details

*   **URL**: `/api/webhook`
*   **Methode**: `POST`
*   **Beschreibung**: Dieser Endpunkt empfängt eine JSON-Nachricht, leitet sie an den internen `intelligentWebhook` AI Flow weiter und gibt die von der KI getroffene Tool-Auswahl zurück.

## Request

### Header

*   `Content-Type: application/json` (Erforderlich)

### Body

Der Request Body muss ein JSON-Objekt mit der Eigenschaft `message` enthalten.

| Feld     | Typ      | Beschreibung                               | Erforderlich |
| :------- | :------- | :----------------------------------------- | :----------- |
| `message` | `string` | Der Text der Benutzereingabe, die von der KI verarbeitet werden soll. | Ja           |

**Beispiel Request Body:**

```json
{
  "message": "Analysiere die Verkaufszahlen des letzten Quartals und finde die umsatzstärksten Produkte."
}
```

## Response

Der Endpunkt gibt ein JSON-Objekt zurück, das die von der KI getroffene Tool-Auswahl und deren Begründung enthält.

### Erfolgreiche Response (Status: 200 OK)

| Feld          | Typ      | Beschreibung                               |
| :------------ | :------- | :----------------------------------------- |
| `toolSelected` | `string` | Der Name des von der KI ausgewählten Tools/Fähigkeit. |
| `reasoning`   | `string` | Die Begründung der KI für die Auswahl dieses Tools. |

**Beispiel Erfolgreiche Response:**

```json
{
  "toolSelected": "DataAnalysis",
  "reasoning": "The user's request clearly indicates a need to analyze sales figures, which falls under data analysis."
}
```

### Fehler-Response (Status: 400 Bad Request, 500 Internal Server Error)

Im Falle eines Fehlers wird ein JSON-Objekt mit einer `error`-Eigenschaft zurückgegeben.

| Feld    | Typ      | Beschreibung                               |
| :------ | :------- | :----------------------------------------- |
| `error` | `string` | Eine Beschreibung des aufgetretenen Fehlers. |

**Beispiel Fehler-Response (400 Bad Request):**

```json
{
  "error": "Message is required"
}
```

**Beispiel Fehler-Response (500 Internal Server Error):**

```json
{
  "error": "Internal Server Error"
}
```

## Beispiel mit `curl`

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "message": "Plane eine 3-tägige Reise nach Paris."
  }' \
  http://localhost:3000/api/webhook
```

Dieser Endpunkt ist ein zentraler Bestandteil der Interaktion mit der KI-Logik von ReplicateAI und ermöglicht eine flexible Integration in externe Automatisierungsworkflows.# Referenz: Umgebungsvariablen

Dieses Dokument listet und beschreibt die Umgebungsvariablen, die zur Konfiguration der ReplicateAI-Anwendung verwendet werden. Diese Variablen sollten in einer `.env`-Datei im Stammverzeichnis des Projekts definiert werden.

## 1. `.env` Datei

Die `.env`-Datei enthält Schlüssel-Wert-Paare für die Umgebungsvariablen. Ein Beispiel:

```env
GEMINI_API_KEY=IHR_GEMINI_API_SCHLÜSSEL
N8N_WEBHOOK_URL=IHRE_N8N_WEBHOOK_URL
NEXT_PUBLIC_SUPABASE_URL=IHRE_SUPABASE_URL
NEXT_PUBLIC_SUPABASE_ANON_KEY=IHR_SUPABASE_ANON_KEY
SUPABASE_SERVICE_ROLE_KEY=IHR_SUPABASE_SERVICE_ROLE_KEY
```

**Wichtig**: Die `.env`-Datei sollte niemals in die Versionskontrolle (Git) aufgenommen werden. Fügen Sie `.env` zu Ihrer `.gitignore`-Datei hinzu.

## 2. Verfügbare Umgebungsvariablen

| Variable                      | Beschreibung                                                                                                | Verwendung                                                                 | Erforderlich |
| :---------------------------- | :---------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------- | :----------- |
| `GEMINI_API_KEY`              | Ihr API-Schlüssel für den Zugriff auf das Google Gemini AI-Modell über Genkit.                              | Serverseitig (in Genkit AI Flows).                                         | Ja           |
| `N8N_WEBHOOK_URL`             | Die URL des n8n-Webhooks, an den der `intelligentWebhookFlow` die KI-Auswahl sendet.                        | Serverseitig (in `src/ai/flows/intelligent-webhooks.ts`).                  | Ja (für n8n-Integration) |
| `NEXT_PUBLIC_SUPABASE_URL`    | Die URL Ihrer Supabase-Instanz. Das `NEXT_PUBLIC_`-Präfix macht diese Variable im Frontend verfügbar.        | Client- und Serverseitig (in `src/lib/supabase.ts`).                       | Ja           |
| `NEXT_PUBLIC_SUPABASE_ANON_KEY` | Der öffentliche "Anon Key" Ihrer Supabase-Instanz. Das `NEXT_PUBLIC_`-Präfix macht diese Variable im Frontend verfügbar. | Client- und Serverseitig (in `src/lib/supabase.ts`).                       | Ja           |
| `SUPABASE_SERVICE_ROLE_KEY`   | Der Service Role Key Ihrer Supabase-Instanz. Dieser Schlüssel hat erweiterte Berechtigungen und sollte **nur serverseitig** verwendet werden. | Serverseitig (in API-Routen wie `src/app/api/messages/route.ts` für privilegierte Operationen). | Ja (für serverseitige Supabase-Operationen) |

## 3. Zugriff auf Umgebungsvariablen

*   **Serverseitig**: Sie können über `process.env.VARIABLE_NAME` auf Umgebungsvariablen zugreifen.
*   **Clientseitig**: Nur Variablen, die mit `NEXT_PUBLIC_` beginnen, sind im Client-Code verfügbar (z.B. `process.env.NEXT_PUBLIC_SUPABASE_URL`).

## 4. Sensible Daten

Variablen wie `GEMINI_API_KEY` und `SUPABASE_SERVICE_ROLE_KEY` enthalten sensible Daten und sollten niemals im Client-Code verwendet oder exponiert werden. Stellen Sie sicher, dass diese nur in serverseitigen API-Routen oder Genkit Flows verwendet werden.

Die korrekte Konfiguration dieser Umgebungsvariablen ist entscheidend für die ordnungsgemäße Funktion von ReplicateAI und die sichere Verbindung zu externen Diensten wie Google Gemini und Supabase.# Referenz: Datenmodelle

Dieses Dokument beschreibt die wichtigsten Datenmodelle, die in der ReplicateAI-Anwendung verwendet werden, insbesondere die Struktur der Chat-Nachrichten, wie sie in der Supabase-Datenbank gespeichert und im Frontend verwendet werden.

## 1. Message

Das `Message`-Modell repräsentiert eine einzelne Nachricht im Chat. Es wird sowohl serverseitig (API-Routen, Supabase-Interaktion) als auch clientseitig (Anzeige im Chat) verwendet.

### TypeScript Interface (`src/types/index.ts`)

```typescript
export interface Message {
  id: string;
  text: string;
  sender: 'user' | 'assistant' | 'system';
  timestamp: Date;
  file?: FileObject;
  reasoning?: string;
}

export interface FileObject {
  id: string;
  name: string;
  type: string;
  url: string; // Can be a blob URL for local preview or a remote URL
  size: number;
  isImage: boolean;
  dataAiHint?: string; // For placeholder images from design
}
```

### Supabase Datenbank Tabelle (`messages`)

Die `messages`-Tabelle in Supabase speichert die persistenten Chat-Nachrichten. Die Struktur entspricht weitgehend dem `Message`-Interface, mit einigen Anpassungen für die Datenbank.

*   **Tabelle**: `messages`
*   **Schema (SQL)**:
    ```sql
    CREATE TABLE messages (
      id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
      text TEXT NOT NULL,
      sender VARCHAR(20) NOT NULL CHECK (sender IN ('user', 'assistant', 'system')),
      timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
      file_data JSONB, -- Speichert das FileObject als JSONB
      reasoning TEXT,
      created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() -- Automatisch generierter Zeitstempel
    );
    ```

### Feld-Beschreibung

| Feld          | Typ (TypeScript)             | Typ (Supabase SQL)        | Beschreibung                                                                 |
| :------------ | :--------------------------- | :------------------------ | :--------------------------------------------------------------------------- |
| `id`          | `string`                     | `UUID`                    | Eindeutige Kennung der Nachricht.                                            |
| `text`        | `string`                     | `TEXT`                    | Der Inhalt der Chat-Nachricht.                                               |
| `sender`      | `'user' \| 'assistant' \| 'system'` | `VARCHAR(20)`             | Der Absender der Nachricht. Beschränkt auf die Werte 'user', 'assistant', 'system'. |
| `timestamp`   | `Date`                       | `TIMESTAMP WITH TIME ZONE` | Der Zeitpunkt, zu dem die Nachricht erstellt wurde.                          |
| `file`        | `FileObject \| undefined`    | `JSONB`                   | (Optional) Details zu einer angehängten Datei, gespeichert als JSON-Objekt.  |
| `reasoning`   | `string \| undefined`        | `TEXT`                    | (Optional) Begründung der KI für die Tool-Auswahl.                           |
| `created_at`  | *Nicht im Interface*         | `TIMESTAMP WITH TIME ZONE` | Automatisch generierter Zeitstempel der Tabellenerstellung. Wird oft für Sortierung verwendet. |

## 2. FileObject

Das `FileObject`-Modell beschreibt eine Datei, die an eine Nachricht angehängt ist. Es ist Teil des `Message`-Modells.

### TypeScript Interface (`src/types/index.ts`)

Siehe oben im Abschnitt "Message".

### Speicherung

`FileObject` wird als JSONB-Objekt in der `file_data`-Spalte der `messages`-Tabelle in Supabase gespeichert.

### Feld-Beschreibung

| Feld        | Typ       | Beschreibung                                                                 |
| :---------- | :-------- | :--------------------------------------------------------------------------- |
| `id`        | `string`  | Eindeutige Kennung der Datei.                                                |
| `name`      | `string`  | Der Dateiname.                                                               |
| `type`      | `string`  | Der MIME-Typ der Datei (z.B. `image/png`, `application/pdf`).                |
| `url`       | `string`  | Die URL zum Zugriff auf die Datei (z.B. Blob-URL für lokale Vorschau, Supabase Storage URL). |
| `size`      | `number`  | Die Größe der Datei in Bytes.                                                |
| `isImage`   | `boolean` | Gibt an, ob die Datei ein Bild ist (für die Vorschau).                       |
| `dataAiHint`| `string`  | (Optional) Hinweis für die KI oder Design-Platzhalter.                       |

Diese Datenmodelle sind entscheidend für das Verständnis, wie Chat-Nachrichten und angehängte Dateien in ReplicateAI strukturiert und verwaltet werden.# Referenz: Konfiguration

Dieses Dokument beschreibt die verschiedenen Konfigurationsmöglichkeiten für die ReplicateAI-Anwendung. Die meisten Konfigurationen erfolgen über Umgebungsvariablen, die in der `.env`-Datei im Stammverzeichnis des Projekts definiert werden.

## 1. Umgebungsvariablen

Die wichtigsten Konfigurationen werden über Umgebungsvariablen gesteuert. Eine vollständige Liste und Beschreibung finden Sie in der [Umgebungsvariablen-Referenz](environment-variables.md).

Beispiele für wichtige Umgebungsvariablen:

*   `GEMINI_API_KEY`: API-Schlüssel für das Google Gemini AI-Modell.
*   `N8N_WEBHOOK_URL`: URL des n8n-Webhooks für die KI-gesteuerte Tool-Ausführung.
*   `NEXT_PUBLIC_SUPABASE_URL`: URL Ihrer Supabase-Instanz (öffentlich).
*   `NEXT_PUBLIC_SUPABASE_ANON_KEY`: Öffentlicher Supabase Anon Key (öffentlich).
*   `SUPABASE_SERVICE_ROLE_KEY`: Supabase Service Role Key (nur serverseitig).

## 2. Anwendungsinterne Konfiguration

Einige Einstellungen sind direkt im Code oder in Konfigurationsdateien innerhalb des Projekts definiert.

### 2.1. Genkit AI Konfiguration

Die Konfiguration für Genkit AI, einschließlich der verwendeten Modelle und Flows, ist in den Dateien im `src/ai/`-Verzeichnis definiert.

*   [`src/ai/genkit.ts`](src/ai/genkit.ts): Hauptkonfiguration für Genkit.
*   [`src/ai/dev.ts`](src/ai/dev.ts): Spezifische Konfiguration für die Entwicklungsumgebung.
*   [`src/ai/flows/intelligent-webhooks.ts`](src/ai/flows/intelligent-webhooks.ts): Definition des `intelligentWebhookFlow` und des `toolSelectionPrompt`.

Änderungen an den verfügbaren Tools oder der Prompt-Logik erfordern Anpassungen in [`intelligent-webhooks.ts`](src/ai/flows/intelligent-webhooks.ts).

### 2.2. Tailwind CSS Konfiguration

Das Styling der Anwendung wird mit Tailwind CSS verwaltet. Die Konfiguration befindet sich in:

*   [`tailwind.config.ts`](tailwind.config.ts): Hauptkonfigurationsdatei für Tailwind CSS.
*   [`postcss.config.mjs`](postcss.config.mjs): PostCSS-Konfiguration.

Anpassungen an Design-Token, Farben, Schriftarten oder Breakpoints werden hier vorgenommen.

### 2.3. Shadcn/ui Konfiguration

Die UI-Komponenten basieren auf Shadcn/ui. Die Konfiguration und die Komponenten selbst befinden sich in `src/components/ui/`.

*   [`components.json`](components.json): Konfigurationsdatei für Shadcn/ui.

### 2.4. Öffentliche Einstellungen API

Die Anwendung stellt einen einfachen API-Endpunkt bereit, um bestimmte Einstellungen für das Frontend abzurufen.

*   **Endpunkt**: `/api/settings`
*   **Datei**: [`src/app/api/settings/route.ts`](src/app/api/settings/route.ts)
*   **Konfiguration**: Derzeit wird die Begrüßungsnachricht direkt in dieser Datei oder über eine externe Quelle (wie `src/data/settings.json`) bezogen.

### 2.5. Datenkonfiguration (settings.json)

Einige statische Einstellungen können in JSON-Dateien gespeichert werden.

*   [`src/data/settings.json`](src/data/settings.json): Kann verwendet werden, um Einstellungen wie die Begrüßungsnachricht oder andere Frontend-Konfigurationen zu speichern.

## 3. Datenbank-Schema

Die Struktur der in Supabase gespeicherten Daten ist ein wichtiger Teil der Konfiguration.

*   **Schema**: Definiert in der `messages`-Tabelle in Supabase (siehe [How-To: Supabase einrichten](how-to/setup-supabase.md)).
*   **TypeScript-Typen**: Die entsprechenden TypeScript-Typen sind in [`src/lib/supabase.ts`](src/lib/supabase.ts) und [`src/types/index.ts`](src/types/index.ts) definiert.

Durch das Verständnis dieser Konfigurationspunkte können Sie das Verhalten und Aussehen der ReplicateAI-Anwendung an Ihre spezifischen Bedürfnisse anpassen.# Tutorial: Webhooks einrichten

Dieses Tutorial führt Sie durch die Einrichtung der ausgehenden Webhook-Funktionalität in ReplicateAI, um die KI-gesteuerte Tool-Auswahl mit einem externen Dienst wie n8n zu verbinden.

## 1. Voraussetzungen

*   Eine laufende ReplicateAI-Anwendung (siehe [Tutorial: Erste Schritte](getting-started.md)).
*   Eine laufende n8n-Instanz (lokal oder gehostet).

## 2. n8n-Webhook-URL abrufen

Sie benötigen eine Webhook-URL von Ihrer n8n-Instanz, die ReplicateAI aufrufen kann.

1.  **Neuen Workflow in n8n erstellen**: Öffnen Sie Ihre n8n-Instanz und erstellen Sie einen neuen, leeren Workflow.
2.  **Webhook-Node hinzufügen**: Suchen Sie in der Node-Palette nach "Webhook" und fügen Sie ihn Ihrem Workflow hinzu.
3.  **Webhook-Node konfigurieren**:
    *   Klicken Sie auf den Webhook-Node, um seine Einstellungen zu öffnen.
    *   Stellen Sie sicher, dass die "HTTP Method" auf `POST` eingestellt ist.
    *   Klicken Sie auf "Webhook URLs". Sie sehen eine Test-URL und eine Produktions-URL.
    *   **Kopieren Sie die "Test Webhook URL"**. Diese URL wird für die lokale Entwicklung von ReplicateAI verwendet.
4.  **Workflow speichern**: Speichern Sie Ihren n8n-Workflow.

## 3. `N8N_WEBHOOK_URL` in ReplicateAI konfigurieren

Öffnen Sie die `.env`-Datei in Ihrem ReplicateAI-Projekt und fügen Sie die kopierte n8n-Webhook-URL hinzu.

1.  **`.env` Datei öffnen**: Suchen Sie die `.env`-Datei im Stammverzeichnis Ihres Projekts.
2.  **Variable hinzufügen/aktualisieren**: Fügen Sie die folgende Zeile hinzu oder aktualisieren Sie sie mit Ihrer n8n-Test-Webhook-URL:

    ```env
    N8N_WEBHOOK_URL=Ihre_n8n_Test_Webhook_URL_hier
    ```
    *Ersetzen Sie den Platzhalter durch die URL, die Sie in Schritt 2.3 kopiert haben.*

3.  **ReplicateAI neu starten**: Wenn Ihre ReplicateAI-Anwendung bereits läuft, starten Sie den Entwicklungs-Server neu, damit die neue Umgebungsvariable geladen wird.

## 4. n8n-Workflow testen

Jetzt können Sie testen, ob ReplicateAI den Webhook an n8n sendet.

1.  **n8n-Workflow aktivieren**: Stellen Sie sicher, dass Ihr n8n-Workflow aktiv ist (der Schalter oben rechts im Workflow-Editor sollte grün sein).
2.  **ReplicateAI Chat öffnen**: Gehen Sie zurück zum ReplicateAI Chat-Interface in Ihrem Browser (`http://localhost:3000`).
3.  **Nachricht senden**: Senden Sie eine Nachricht im ReplicateAI Chat, die eine klare Absicht für eines der [KI-Tools](explanation/ai-intelligence.md) hat.
    *   Beispiel: "Analysiere die Daten in dieser Tabelle." (Dies sollte das "DataAnalysis"-Tool auslösen).
4.  **n8n-Ausführung prüfen**: Wechseln Sie zurück zu Ihrer n8n-Instanz. Im Webhook-Node sollten Sie sehen, dass eine Ausführung stattgefunden hat. Klicken Sie auf den Webhook-Node und dann auf "Input Data", um die von ReplicateAI gesendeten Daten zu sehen (ein JSON-Objekt mit `toolSelected` und `reasoning`).

## 5. n8n-Workflow erweitern

Nachdem Sie bestätigt haben, dass der Webhook empfangen wird, können Sie Ihren n8n-Workflow erweitern, um basierend auf dem Wert von `toolSelected` Aktionen auszuführen.

*   Verwenden Sie einen "If"-Node, um verschiedene Zweige für verschiedene Tools zu erstellen.
*   Fügen Sie Nodes hinzu, um die tatsächliche Logik für jedes Tool zu implementieren (z.B. einen "HTTP Request"-Node, um eine externe API aufzurufen, einen "Function"-Node, um Daten zu verarbeiten).

Weitere Details zur Erweiterung des n8n-Workflows finden Sie im [How-To: Neue KI-Tools integrieren](how-to/integrate-ai-tools.md) Leitfaden.

Durch die Einrichtung dieses Webhooks haben Sie die Grundlage geschaffen, um die intelligenten Entscheidungen von ReplicateAI in leistungsstarke Automatisierungsworkflows in n8n zu integrieren.# Tutorial: Erste Schritte mit ReplicateAI

Dieses Tutorial führt Sie durch die grundlegenden Schritte, um das ReplicateAI-Projekt lokal einzurichten und auszuführen. Am Ende dieses Tutorials haben Sie eine laufende Instanz der Anwendung und können mit dem Chat-Interface interagieren.

## 1. Voraussetzungen

Stellen Sie sicher, dass die folgenden Voraussetzungen auf Ihrem System erfüllt sind:

*   **Node.js**: Version 18 oder höher. Sie können dies mit `node -v` überprüfen.
*   **npm**: Node Package Manager, der mit Node.js installiert wird. Überprüfen Sie die Version mit `npm -v`.
*   **Git**: Für das Klonen des Repositorys. Überprüfen Sie die Version mit `git --version`.
*   **Google Cloud Projekt & Gemini API Key**: Sie benötigen einen API-Schlüssel für das Google Gemini Modell, um die KI-Funktionalität nutzen zu können. Anleitungen finden Sie in der Google Cloud Dokumentation.
*   **Supabase Projekt**: Sie benötigen ein Supabase-Projekt für die Speicherung der Chat-Nachrichten. Folgen Sie dem [How-To: Supabase einrichten](how-to/setup-supabase.md) Leitfaden, um dies einzurichten.
*   **n8n Instanz (Optional)**: Wenn Sie die ausgehende Webhook-Funktionalität testen möchten, benötigen Sie eine laufende n8n-Instanz und eine Webhook-URL (siehe [How-To: Webhooks konfigurieren](how-to/configure-webhooks.md)).

## 2. Repository klonen

Öffnen Sie Ihr Terminal und klonen Sie das ReplicateAI-Repository von GitHub:

```bash
git clone https://github.com/your-repo/replicateai.git
cd replicateai
```
*Ersetzen Sie `https://github.com/your-repo/replicateai.git` durch die tatsächliche URL des Repositorys.*

## 3. Abhängigkeiten installieren

Installieren Sie alle erforderlichen Projekt-Abhängigkeiten mit npm:

```bash
npm install
```

## 4. Umgebungsvariablen konfigurieren

Erstellen Sie eine `.env`-Datei im Stammverzeichnis des Projekts und konfigurieren Sie die erforderlichen Umgebungsvariablen.

1.  **`.env` Datei erstellen**:
    ```bash
    touch .env
    ```
2.  **`.env` Datei bearbeiten**: Öffnen Sie die `.env`-Datei in Ihrem Code-Editor und fügen Sie die folgenden Variablen hinzu. Ersetzen Sie die Platzhalter durch Ihre tatsächlichen Anmeldeinformationen:

    ```env
    GEMINI_API_KEY=IHR_GEMINI_API_SCHLÜSSEL
    N8N_WEBHOOK_URL=IHRE_N8N_WEBHOOK_URL # Optional, wenn Sie n8n nutzen
    NEXT_PUBLIC_SUPABASE_URL=IHRE_SUPABASE_URL
    NEXT_PUBLIC_SUPABASE_ANON_KEY=IHR_SUPABASE_ANON_KEY
    SUPABASE_SERVICE_ROLE_KEY=IHR_SUPABASE_SERVICE_ROLE_KEY # Nur serverseitig verwenden
    ```
    *Details zu diesen Variablen finden Sie in der [Umgebungsvariablen-Referenz](reference/environment-variables.md).*

## 5. Supabase-Datenbank einrichten

Stellen Sie sicher, dass Ihre Supabase-Datenbank eingerichtet ist und die `messages`-Tabelle existiert. Folgen Sie dazu dem [How-To: Supabase einrichten](how-to/setup-supabase.md) Leitfaden, falls noch nicht geschehen.

## 6. Anwendung starten

Starten Sie den Next.js-Entwicklungs-Server:

```bash
npm run dev
```

Die Anwendung sollte nun unter `http://localhost:3000` verfügbar sein.

## 7. Anwendung testen

Öffnen Sie Ihren Webbrowser und navigieren Sie zu `http://localhost:3000`. Sie sollten das ReplicateAI Chat-Interface sehen.

*   Senden Sie eine Nachricht im Chat. Diese sollte in Ihrer Supabase-Datenbank gespeichert werden.
*   Wenn Sie die n8n-Integration konfiguriert haben, beobachten Sie Ihren n8n-Workflow, um zu sehen, ob der Webhook ausgelöst wird, nachdem die KI eine Tool-Auswahl getroffen hat.

Herzlichen Glückwunsch! Sie haben ReplicateAI erfolgreich lokal eingerichtet und ausgeführt. Sie können nun mit der Erkundung der Anwendung und ihrer Funktionen beginnen.# Tutorial: Ihre erste Chat-Sitzung

Dieses Tutorial führt Sie durch Ihre erste Interaktion mit dem ReplicateAI Chat-Interface und zeigt Ihnen, wie Sie Nachrichten senden und die KI-gesteuerte Tool-Auswahl erleben können.

## 1. Anwendung starten

Stellen Sie sicher, dass Ihre ReplicateAI-Anwendung lokal läuft. Wenn nicht, folgen Sie dem [Tutorial: Erste Schritte](getting-started.md), um sie einzurichten und zu starten.

Öffnen Sie Ihren Webbrowser und navigieren Sie zu `http://localhost:3000`.

## 2. Das Chat-Interface

Sie sollten das ReplicateAI Chat-Interface sehen. Es besteht typischerweise aus:

*   **Nachrichtenliste**: Der Bereich, in dem die gesendeten und empfangenen Nachrichten angezeigt werden.
*   **Nachrichteneingabe**: Ein Textfeld am unteren Rand, in das Sie Ihre Nachrichten eingeben können.
*   **Senden-Button**: Ein Button, um Ihre Nachricht abzuschicken.

## 3. Eine Nachricht senden

1.  **Nachricht eingeben**: Klicken Sie in das Textfeld am unteren Rand des Chats.
2.  **Text eingeben**: Geben Sie eine Nachricht ein. Versuchen Sie eine Nachricht, die eine bestimmte Aufgabe impliziert, die einem der definierten [KI-Tools](explanation/ai-intelligence.md) entspricht.
    *   Beispiel: "Kannst du mir helfen, einen Entwurf für eine Marketing-E-Mail zu schreiben?"
3.  **Nachricht senden**: Klicken Sie auf den Senden-Schaltfläche (oft ein Pfeil- oder Papierflugzeug-Symbol) oder drücken Sie die Eingabetaste.

## 4. KI-Antwort und Tool-Auswahl

Nachdem Sie Ihre Nachricht gesendet haben, geschieht Folgendes:

1.  Ihre Nachricht wird in der Nachrichtenliste angezeigt.
2.  Die Anwendung sendet Ihre Nachricht an den internen KI-Flow.
3.  Die KI analysiert Ihre Nachricht und wählt das am besten geeignete Tool aus.
4.  Eine Systemnachricht kann erscheinen, die anzeigt, welches Tool die KI ausgewählt hat und warum (basierend auf der `reasoning`-Eigenschaft).
5.  Eine simulierte Antwort des Assistenten wird angezeigt, die angibt, welches Tool ausgewählt wurde.

Im Beispiel "Kannst du mir helfen, einen Entwurf für eine Marketing-E-Mail zu schreiben?" sollte die KI wahrscheinlich das Tool "ContentGeneration" auswählen.

## 5. Nachrichtenpersistenz

Da ReplicateAI mit Supabase integriert ist, werden alle Nachrichten, die Sie senden und empfangen, in Ihrer Supabase-Datenbank gespeichert.

*   Sie können Ihre Supabase-Datenbank im Supabase-Dashboard überprüfen, um die gespeicherten Nachrichten in der `messages`-Tabelle zu sehen.
*   Wenn Sie die Anwendung neu laden, sollten die zuvor gesendeten Nachrichten aus Supabase geladen und im Chat angezeigt werden.

## 6. Dateianhänge (falls implementiert)

Wenn die Dateianhangsfunktion implementiert ist, können Sie auch Dateien über das Eingabefeld hochladen. Diese Dateien werden im Chat angezeigt und ihre Metadaten (falls konfiguriert) in der Datenbank gespeichert.

Durch diese erste Chat-Sitzung haben Sie die grundlegende Interaktion mit ReplicateAI erlebt und gesehen, wie die KI Ihre Anfragen interpretiert und Tools auswählt.# ReplicateAI Projekt Blueprint

Dieses Dokument diente ursprünglich als erster Entwurf und Überblick über die Kernfeatures und Design-Prinzipien des ReplicateAI-Projekts. Die detailliertere Dokumentation finden Sie nun in der strukturierten `docs/`-Ordnerstruktur, die dem [Diátaxis-Framework](https://diataxis.fr/) folgt.

## Kernfeatures (Ursprünglicher Entwurf):

*   **Chat Interface**: ChatGPT-ähnliche Schnittstelle für den Chat, mit Dark/Light Theme und responsivem Design. Jetzt persistent mit Supabase verbunden.
*   **Intelligent Webhooks**: KI-gesteuerte Tool-Auswahl. LLM "Tool" wählt die Fähigkeit, die am besten zur aktuellen Abfrage passt, und aktiviert Webhooks.
*   **Basic Webhooks**: Grundlegende Webhooks-Funktion zur Weiterleitung von Nachrichteninhalten an Dritte.
*   **Tool execution**: Grundlegende Tool-Ausführung zur Beantwortung mit vordefinierten Nachrichten aus Firebase (Hinweis: Die Tool-Ausführung wird nun idealerweise über n8n-Workflows gehandhabt, ausgelöst durch ausgehende Webhooks).
*   **File Support**: Datei-Upload und Vorschau mit Firebase Storage (temporäre Links), ohne den Datenbankteil (Hinweis: Die Dateiverwaltung kann optional mit Supabase Storage integriert werden).

Weitere Details zu diesen Features und ihrer Implementierung finden Sie in den entsprechenden Abschnitten der strukturierten Dokumentation:

*   [Architektur](explanation/architecture.md)
*   [Kernkonzepte](explanation/core-concepts.md)
*   [KI-Intelligenz und Tool-Auswahl](explanation/ai-intelligence.md)
*   [Webhook-System](explanation/webhook-system.md)
*   [How-To Guides](how-to/setup-supabase.md)
*   [Referenz](reference/api/webhook-api.md)
*   [Tutorials](tutorials/getting-started.md)

## Style Guidelines (Ursprünglicher Entwurf):

*   Primary color: A calm blue (#4285F4) evoking trust and intelligence.
*   Background color: Light gray (#F5F5F5), almost white.
*   Accent color: A soft, muted green (#67B965).
*   Body and headline font: 'Inter', sans-serif.
*   Code font: 'Source Code Pro'.
*   Lucide Icons; clean, simple line icons.
*   Subtle animations for message loading and interactions, using Framer Motion.

Diese Style Guidelines sind nun im [Style Guide](contributing/STYLE_GUIDE.md) für Mitwirkende dokumentiert.

Dieses Blueprint-Dokument wird als historischer Überblick beibehalten. Für die aktuellste und detaillierteste Dokumentation navigieren Sie bitte zum Haupt-README im `docs/`-Ordner.